// Generated by BUCKLESCRIPT VERSION 3.0.0, PLEASE EDIT WITH CARE
'use strict';

var Curry = require("bs-platform/lib/js/curry.js");
var Belt_List = require("bs-platform/lib/js/belt_List.js");
var Caml_oo_curry = require("bs-platform/lib/js/caml_oo_curry.js");
var CamlinternalOO = require("bs-platform/lib/js/camlinternalOO.js");

var class_tables = [
  0,
  0,
  0
];

function streamBase(transform, _) {
  if (!class_tables[0]) {
    var $$class = CamlinternalOO.create_table([
          "peek",
          "pour",
          "on"
        ]);
    var env = CamlinternalOO.new_variable($$class, "");
    var ids = CamlinternalOO.new_methods_variables($$class, [
          "pour",
          "peek",
          "on"
        ], [
          "value",
          "listeners"
        ]);
    var pour = ids[0];
    var peek = ids[1];
    var on = ids[2];
    var value = ids[3];
    var listeners = ids[4];
    CamlinternalOO.set_methods($$class, /* array */[
          on,
          (function (self$1, listner) {
              self$1[listeners][0] = /* :: */[
                listner,
                self$1[listeners][0]
              ];
              var match = self$1[value][0];
              if (match) {
                return Curry._1(listner, match[0]);
              } else {
                return /* () */0;
              }
            }),
          pour,
          (function (self$1, chunk) {
              self$1[value][0] = Curry._2(self$1[env][0], self$1[value][0], /* Some */[chunk]);
              var match = self$1[value][0];
              if (match) {
                var transformedChunk = match[0];
                return Belt_List.forEach(self$1[listeners][0], (function (map) {
                              return Curry._1(map, transformedChunk);
                            }));
              } else {
                return /* () */0;
              }
            }),
          peek,
          (function (self$1, _) {
              return self$1[value][0];
            })
        ]);
    var env_init = function (env$1) {
      var self = CamlinternalOO.create_object_opt(0, $$class);
      self[value] = [Curry._2(env$1[1], /* None */0, /* None */0)];
      self[listeners] = [/* [] */0];
      self[env] = env$1[0];
      return self;
    };
    CamlinternalOO.init_class($$class);
    class_tables[0] = env_init;
  }
  return Curry._1(class_tables[0], [
              [transform],
              transform
            ]);
}

function wrapScanAsTransformer(fn, defautAccValue, acc, chunk) {
  if (chunk) {
    var c = chunk[0];
    if (acc) {
      return /* Some */[Curry._2(fn, acc[0], c)];
    } else {
      return /* Some */[Curry._2(fn, defautAccValue, c)];
    }
  } else {
    return /* Some */[defautAccValue];
  }
}

function createTransfomer(fn, _, chunk) {
  if (chunk) {
    return /* Some */[Curry._1(fn, chunk[0])];
  } else {
    return /* None */0;
  }
}

function stream() {
  return streamBase((function (param, param$1) {
                return createTransfomer((function (i) {
                              return i;
                            }), param, param$1);
              }), /* () */0);
}

function on(fn, stream) {
  return Caml_oo_curry.js2(24863, 1, stream, fn);
}

function pipe(pipedStream, inputStream) {
  return Caml_oo_curry.js2(24863, 3, inputStream, Caml_oo_curry.js1(-899906020, 2, pipedStream));
}

function pour(chunk, stream) {
  return Caml_oo_curry.js2(-899906020, 4, stream, chunk);
}

function map(cb) {
  return streamBase((function (param, param$1) {
                return createTransfomer(cb, param, param$1);
              }), /* () */0);
}

function mapAndPipe(cb, inputStream) {
  var mapperStream = streamBase((function (param, param$1) {
          return createTransfomer(cb, param, param$1);
        }), /* () */0);
  pipe(mapperStream, inputStream);
  return mapperStream;
}

function scan(cb, $$default) {
  return streamBase((function (param, param$1) {
                return wrapScanAsTransformer(cb, $$default, param, param$1);
              }), /* () */0);
}

function scanAndPipe(cb, $$default, inputStream) {
  var scannerStream = scan(cb, $$default);
  pipe(scannerStream, inputStream);
  return scannerStream;
}

exports.streamBase = streamBase;
exports.wrapScanAsTransformer = wrapScanAsTransformer;
exports.createTransfomer = createTransfomer;
exports.stream = stream;
exports.on = on;
exports.pipe = pipe;
exports.pour = pour;
exports.map = map;
exports.mapAndPipe = mapAndPipe;
exports.scan = scan;
exports.scanAndPipe = scanAndPipe;
/* No side effect */
